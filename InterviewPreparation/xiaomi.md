# position: sticky与fixed

sticky 是滚动到某个位置前是相对定位（relative），到达之后变成“固定”；而 fixed 是始终固定在视口某位置，脱离文档流。sticky不脱离文档流。

# 浏览器用了哪些进程和线程
进程： 浏览器主进程	 渲染进程	 GPU 进程	网络进程	插件进程	
线程： GUI 渲染线程	 JS 引擎线程	事件触发线程	定时器线程	异步网络线程	

# fiber的理解，以及fiber为什么可以可中断渲染

# fiber渲染的帧率
5ms-16ms
# V8垃圾回收机制
1. 标记-清除（Mark-and-Sweep）
V8 使用标记-清除算法来回收垃圾对象。基本过程如下：

标记阶段（Marking phase）：

V8 会从根对象（例如，全局对象、活动的函数调用栈等）出发，递归地标记所有可达的对象（即仍然有引用的对象）。

每个可达对象都会被标记为活跃的。

清除阶段（Sweeping phase）：

一旦标记阶段完成，V8 会遍历整个堆，清理那些没有被标记的对象（即不再被引用的对象）。

这些无用对象的内存会被释放，从而使内存可用于新的对象。

2. 分代垃圾回收（Generational GC）
V8 引入了分代垃圾回收策略，通过假设“新生代对象很可能很快就不再需要”来优化回收过程。

分代堆：

V8 将堆分为两个主要区域：

新生代（Young Generation）： 存储新创建的对象。新对象通常寿命较短，不会存在太长时间。

老生代（Old Generation）： 存储经过多次垃圾回收仍然存活下来的对象。

垃圾回收的分代策略：

新生代对象使用 Scavenge（拷贝收集）算法进行垃圾回收，收集速度很快。

老生代对象则使用 Mark-and-Sweep 或 Mark-Compact（标记整理）算法，回收速度较慢，但它是清理较大、较老的对象。

3. 垃圾回收的触发
垃圾回收并不是在每次内存分配时就触发的，而是通过以下方式触发：

新生代（Young Generation）：

新生代使用拷贝收集。当新生代的内存区域满时，会触发垃圾回收，回收过程中将会执行两次：

Minor GC（小范围回收）： 只针对新生代回收，清理掉不再需要的对象，清理速度较快。

Major GC（大范围回收）： 在新生代频繁回收的情况下，如果对象有一部分晋升到老生代，V8 会进行老生代的回收。

老生代（Old Generation）：

如果老生代内存压力增大（例如存活了多次 Minor GC），会触发 Major GC。此时会回收老生代内存，这通常会比 Minor GC 更慢。

4. 增量和并发回收（Incremental and Concurrent GC）
为了避免垃圾回收过程阻塞主线程，V8 引擎引入了增量回收和并发回收策略。

增量回收（Incremental GC）：

通过将回收过程拆分成小的增量步骤，每次回收只进行少量工作，避免一次性回收造成的长时间卡顿。

这样，垃圾回收就能在多个事件循环中分阶段执行，不会阻塞用户操作。

并发回收（Concurrent GC）：

部分回收工作会在与应用程序代码并发的情况下执行（例如在后台线程），这能进一步减少卡顿。

- V8 的垃圾回收机制结合了标记-清除算法和分代收集策略，力求提高效率，减少回收时对程序的影响。具体来说，垃圾回收的过程主要包括：

标记-清除： 标记存活对象并清理垃圾对象。

分代收集： 新生代对象频繁回收，老生代对象较少回收。

增量和并发： 通过将回收拆分为小步骤或在后台执行，避免阻塞主线程。

V8 采用这些优化策略，能够提高性能并减少对应用程序的干扰，让垃圾回收变得更加高效。

# playwright的api
toHaveScreenshot 截图并比对

# 手写reduce